package com.wh.test.shejimoshi.sjmsStructuralPattern.sjmsFlyWeight;/*
一、享元模式介绍
享元模式（FlyWeight）：运用共享技术有效的支持大量细粒度对象的重用。
应用场景：如果项目中有很多完全相同或相似的对象，则可以使用享元模式，节省内存。
享元对象能做到共享的关键就是区分了内部状态和外部状态。
内部状态：可以共享，不会随环境变化而变化
外部状态：不可以共享，会随环境变化而变化

FlyweightFactory（享元工厂类）：创建并管理享元对象，享元池一般设计成键值对
FlyWeight（抽象享元类）：通常是一个接口或者抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。
ConcreteFlyWeight（具体享元类）：为内部状态提供成员变量进行存储
UnsharedConcreteFlyWeight（非共享享元类）：不能被共享的子类可以设计为非共享享元类

例如：围棋中的享元模式，在围棋中，所有的白色或黑色的（形状、大小，颜色都一样）只是位置不同，那像这样的情况，可以使用享元模式。
把颜色、形状、大小给共享出来（内部状态）。位置不共享（外部状态）
 */


/*
三、享元模式应用场景
享元模式开发中应用场景：
比如线程池，数据库连接池，这些都利用享元模式共享了部分属性，在池中操作。
String类的设计也是享元模式
优点：
1.极大的减少内存中对象的数量
2.相同或相似对象内存中只存在一份，极大的节约资源，提高系统性能
3.外部状态相对独立，不影响内部状态
缺点：
1.模式较复杂，使程序逻辑复杂化
2.为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态使运行时间变长。
 */


//FlyWeight（抽象享元类）:通常是一个接口或者抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。
/**
 * 享元类接口：可以共享的有颜色，大小，形状
 * FlyWeight（抽象享元类）：通常是一个接口或者抽象类，声明公共方法，
 * 这些方法可以向外界提供对象的内部状态，设置外部状态。
 */
public interface ChessFlyWeight {
    //这里只设置一个颜色,大小和形状省略
    void setColor(String c);
    String getColor();
    void display(Coordinate c);//显示棋子
}